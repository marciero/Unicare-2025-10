---
title: "Zer0 inflated Models for Inpatient Admissions"
date: "`r Sys.Date()`"
title-slide-attributes:
  data-background-image: UNE_pantone.png
  data-background-size: stretch
format: 
    html:
        freeze: auto
        embed-resources: true
editor_options: 
  chunk_output_type: console
---

```{r knitr, warning=FALSE, include=FALSE}
options(htmltools.dir.version = FALSE, digits = 3)
knitr::opts_chunk$set(
  fig.width=7.5, fig.height=4.2, fig.retina=3,
  out.width = "100%",
  cache = FALSE,
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.show = TRUE,
  hiline = TRUE,
  require("knitr")
)

```

```{r echo=FALSE, warning=FALSE, include=FALSE}

library(tidyverse)
library(tidymodels)
library(poissonreg)   
#library(MASS)
library(MetBrewer)
library(wesanderson)

library(lubridate)

library(broom)
library(pscl)
library(patchwork)
library(kableExtra)

library(rstan)
library(bayesplot)
library(brms)
library(bayesrules)





```

```{r}
event_file <- "../../data/2025_10_15_utilization_events.csv"
report_file <- "../../data/2025_10_15_utilization_report.csv"

#setwd("~/Dropbox/DS-stats/stats/zero_inf_talk")

source("../R_files/read_clean.R")
```

We consider `Unicare - Study` vs all other members, using `cohort`, as well as select other covariates. Even in the event ignorability, balance, and other assumptions, they often result in reduced bias and efficiency (lower variance) of estimates.

## Regression Models

-   Negative binomial regression; intercept only and with `cohort` as covariate

-   Zero inflated Poisson and negative binomial; `cohort` and select other covariates on count and zero inflation portions of the model

-   Bayesian versions of the above

```{r}

clrs1 <- MetBrewer::met.brewer("Lakota")

clrs2 <- MetBrewer::met.brewer("Tiepolo")
clrs3 <- MetBrewer::met.brewer("OKeeffe2")
clrs4 <- MetBrewer::met.brewer("VanGogh3")
clrs5 <- MetBrewer::met.brewer("Homer1")

```

# Modeling Hospital Admissions counts

```{r echo = FALSE}

term <- 270

ibis_inpatient_table <- events_full %>%  filter(org_name == "Unicare - Study")  %>%
    filter(event_type == "inpatient", event_start_date > ibis_coverage_start_date & 
           event_start_date < ibis_coverage_end_date) %>%
    filter(term !=0 & event_start_date < ibis_coverage_start_date + term |
              term == 0 & event_start_date > ibis_coverage_start_date) %>%
   summarize(.by = pid, inpatient_count = n()) %>% 
    mutate(cohort = "ibis")

control_inpatient_table <- events_full %>%  filter(org_name != "Unicare - Study")  %>%
    filter(event_type == "inpatient", event_start_date < ibis_coverage_start_date &
           event_start_date > coverage_start_date) %>% 
    filter(term !=0 & event_start_date > ibis_coverage_start_date - term |
            term == 0 & event_start_date < ibis_coverage_start_date) %>%
    summarize(.by = pid, inpatient_count = n()) %>% 
    mutate(cohort = "control")


ibis_coverage_table <- report_full %>% 
    filter(org_name == "Unicare - Study") %>% 
      #filter(str_detect(org_name, "Unicare")) %>%
    filter(ibis_coverage_end_date - ibis_coverage_start_date > term) %>% 
    select(pid) %>% mutate(cohort = "ibis")

control_coverage_table <- report_full %>% 
    filter(org_name != "Unicare - Study") %>% 
      #filter(!str_detect(org_name, "Unicare")) %>%
    filter(ibis_coverage_start_date - coverage_start_date > term) %>% 
    select(pid) %>% mutate(cohort = "control")

coverage_table <- bind_rows(ibis_coverage_table, control_coverage_table)


inpatient_coverage_table <- control_inpatient_table %>% 
    bind_rows(ibis_inpatient_table) %>% right_join(coverage_table, by = c("pid", "cohort")) %>% 
     replace(is.na(.), 0)

```

```{r, eval = FALSE}
inpatient_coverage_table %>% 
  group_by(inpatient_count) %>% 
  summarize(frequency = n()) %>% 
   kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 14)
```

```{r}
patients <- report_full %>% select(pid, age, c(condition_count:urologic_cancer))  %>% 
    filter(pid %in% inpatient_coverage_table$pid)

patients_events <- inpatient_coverage_table %>% inner_join(patients, by = "pid") 
```

```{r}
clrs1 <- MetBrewer::met.brewer("Lakota")
clrs2 <- MetBrewer::met.brewer("Tiepolo")
clrs3 <- MetBrewer::met.brewer("OKeeffe2")

```

We consider admissions occurring within `r term` day window of observation.

```{r}
patients_events %>% 
   summarize(.by = cohort, count = n()) %>%
    kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 22)
```

## Admissions counts

::::: columns
::: {.column width="50%"}
```{r}
patients_events %>% group_by(inpatient_count) %>%
    summarize(frequency = n(), .groups = "drop") %>% 
    mutate(is_zero  = if_else(inpatient_count == 0, "zero", "non-zero")) %>%
    mutate(density = frequency / sum(frequency)) %>% 
    ggplot(aes(x = inpatient_count, y = density)) +
    geom_col(aes(fill = is_zero)) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(limits = c(-0.5,10),
                       breaks = c(0, 5, 10)) + 
    labs(x = "Number of admissions", y =  NULL,
         fill = NULL,
         title = "Overall inpatient admissions") +
    scale_fill_manual(values = c(clrs1[2], clrs1[3])) +
    theme_minimal(base_size = 12) +
    theme(#axis.text.y = element_blank(),
          legend.position = "bottom",
          #strip.background = element_blank(),
          #panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey80", color = NA)
    )

```
:::

::: {.column width="50%"}
```{r}
patients_events %>% 
    group_by(cohort, inpatient_count) %>% 
    summarize(frequency = n(), .groups = "drop") %>% 
    mutate(.by = cohort, density = frequency / sum(frequency)) %>% 
    mutate(is_zero_cohort  = case_when(cohort == "ibis" & inpatient_count == 0 ~ "ibis zero",
                                       cohort == "control" & inpatient_count == 0 ~ "control zero",
                                       cohort == "ibis" & inpatient_count != 0 ~ "ibis non-zero",
                                       cohort == "control" & inpatient_count != 0 ~ "control non-zero"
    )) %>%
    ggplot(aes(x = inpatient_count, y = density)) +
    geom_col(aes(fill = is_zero_cohort), position = "dodge") +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(limits = c(-0.5,10),
                       breaks = c(0, 5, 10)) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_fill_manual(values = c(clrs3[1], clrs2[1], clrs3[2], clrs2[2])) +
    labs(x = "Number of admissions", y =  NULL,
         title = "Inpatient admissions by cohort",
         fill = NULL) +
    theme_minimal(base_size = 12) +
    theme(#axis.text.y = element_blank(),
          #strip.background = element_blank(),
          panel.grid.major = element_blank(),
          #panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey80", color = NA),
          legend.position = "bottom"
    )

```
:::
:::::

::::: columns
::: {.column width="50%"}
Overall

```{r}
patients_events %>% 
    summarize(mean = mean(inpatient_count),
              variance = var(inpatient_count)) %>% 
    kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 20)
```
:::

::: {.column width="50%"}
By cohort

```{r}
patients_events %>% 
    group_by(cohort) %>% 
    summarize(mean = mean(inpatient_count),
              variance = var(inpatient_count), .groups = "drop") %>% 
    kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 20)
```
:::
:::::

With overall variance not equal to the mean, a Poisson model is not appropriate. We consider a negative binomial model, which allows for overdispersion. But note that the dispersion parameter is a global parameter, and not adjusted for cohorts separately. That said, as it is a function of the mean, the variance given by the model *will* be adjusted for cohort.

## Covariates, multicolinearity

Perhaps surprisingly, age and chronic conditions covariates do not exhibit high multicolinearity. This means not only that there are no high pairwise correlations, but that, for example, any one of them is not explainable by the others- regressing any one on the others would results in a low R squared value.

As an illustration, with `condition count` included, the covariates are completely colinear.

Low multicolinearity is a desirable feature for generalized linear models as it results in more stable coefficient estimates.

#### Condition number

We find the condition number of the model matrix with age and other covariates. This the square root of the ratio of max and min eigen values of the correlation matrix, and is thus a ratio of the standard deviations along components of the data with max variation and min variation,

```{r}
admityn <- patients_events %>% mutate(admit = if_else(inpatient_count == 0, 0, 1))

conditions <- admityn %>% select(c(age, condition_count:urologic_cancer)) %>% 
    select(-condition_count)

X <- cor(conditions)
eigs <- eigen(X)

cond_number <- sqrt(max(eigs$values)/min(eigs$values))


```

$\sqrt{\frac{\lambda_{max}}{\lambda_{min}}}$ = `r cond_number`

As a rule of thumb, condition number \> 30 is indication of high multicolinearity.

#### Correlations

Selecting covariates with low multicolinearity is also more straightforward, as simply selecting those most highly correlated with the outcome is more justifiable than in the case of high multicolinearity.

```{r}
cor(conditions, admityn$admit) %>% as.data.frame() %>% arrange(desc(V1)) %>% 
    rownames_to_column(var = "condition") %>% 
    mutate(correlation = V1) %>% select(-V1) %>% 
    kbl(digits = 4)
    
```

We select `age`, `atrial_fibrillation`, and `chf`, variously in the models below.

## Admissions counts; negative binomial

We first compare intercept only and cohort models

::::: columns
::: {.column width="50%"}
```{r}
patients_events %>% group_by(inpatient_count) %>%
    summarize(frequency = n(), .groups = "drop") %>% 
    mutate(is_zero  = if_else(inpatient_count == 0, "zero", "non-zero")) %>%
    mutate(density = frequency / sum(frequency)) %>% 
    ggplot(aes(x = inpatient_count, y = density)) +
    geom_col(aes(fill = is_zero)) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(limits = c(-0.5,10),
                       breaks = c(0, 5, 10)) + 
    labs(x = "Number of admissions", y =  NULL,
         fill = NULL,
         title = "Overall inpatient admissions") +
    scale_fill_manual(values = c(clrs1[2], clrs1[3])) +
    theme_minimal(base_size = 12) +
    theme(#axis.text.y = element_blank(),
          legend.position = "bottom",
          #strip.background = element_blank(),
          #panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey80", color = NA)
    )

```
:::

::: {.column width="50%"}
```{r}
patients_events %>% 
    group_by(cohort, inpatient_count) %>% 
    summarize(frequency = n(), .groups = "drop") %>% 
    mutate(.by = cohort, density = frequency / sum(frequency)) %>% 
    mutate(is_zero_cohort  = case_when(cohort == "ibis" & inpatient_count == 0 ~ "ibis zero",
                                       cohort == "control" & inpatient_count == 0 ~ "control zero",
                                       cohort == "ibis" & inpatient_count != 0 ~ "ibis non-zero",
                                       cohort == "control" & inpatient_count != 0 ~ "control non-zero"
    )) %>%
    ggplot(aes(x = inpatient_count, y = density)) +
    geom_col(aes(fill = is_zero_cohort), position = "dodge") +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(limits = c(-0.5,10),
                       breaks = c(0, 5, 10)) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_fill_manual(values = c(clrs3[1], clrs2[1], clrs3[2], clrs2[2])) +
    labs(x = "Number of admissions", y =  NULL,
         title = "Inpatient admissions by cohort",
         fill = NULL) +
    theme_minimal(base_size = 12) +
    theme(#axis.text.y = element_blank(),
          #strip.background = element_blank(),
          panel.grid.major = element_blank(),
          #panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey80", color = NA),
          legend.position = "bottom"
    )

```
:::
:::::

:::::: columns
::: {.column width="50%"}
$$
\begin{aligned}
{\rm{count}}_i & \sim NB(\mu_i, \theta) \\
\log \mu_i & = \beta_0 
\end{aligned}
$$

```{r}

mod_nb_admit <- MASS::glm.nb(inpatient_count ~ 1, data = patients_events, link = "log")
tidy(mod_nb_admit) %>% mutate(exp_estimate = exp(estimate)) %>% 
    select(c(term, estimate, p.value, exp_estimate)) %>% 
    kbl() %>% kable_paper("hover", full_width = F, html_font = "Arial", font_size = 20)
    
```

[$\theta$: `r round(mod_nb_admit$theta, 3)`]{style="font-size:75%"}
:::

:::: {.column width="50%"}
::: small
$$
\begin{aligned}
{\rm{count}}_i & \sim NB(\mu_i, \theta) \\
\log \mu_i & = \beta_0 + \beta_1 \textrm{cohort}_i 
\end{aligned}
$$
:::

```{r}

mod_nb_admit_2 <- MASS::glm.nb(inpatient_count ~ cohort, data = patients_events, link = "log")
tidy(mod_nb_admit_2) %>% mutate(exp_estimate = exp(estimate)) %>% 
    select(c(term, estimate, p.value, exp_estimate)) %>% 
    kbl() %>% kable_paper("hover", full_width = F, html_font = "Arial", font_size = 20)
    
```

[$\theta$: `r round(mod_nb_admit_2$theta, 3)`]{style="font-size:75%"}
::::
::::::

## Model comparison

Negative binomial [with]{style="color:#931e18"} vs [without]{style="color:#f0be3d"} `cohort` as predictor

<br>

**Likelihood ratio test, ANOVA, p-value on coefficient all equivalent**

```{r}

mod_nb_admit_2 %>% tidy() %>% kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 20)
```

## Predictive check, NB model for admissions counts

#### Model

$$\textrm{counts}_i \sim NB(\mu_i, \theta)$$ $$\log \mu_i = \beta_0 + \beta_1 \textrm{cohort}$$

```{r}
obs_freqs_cohort_inpatient <- patients_events %>%
    group_by(cohort, inpatient_count) %>% 
    summarize(frequency = n()) %>% 
    mutate(density = frequency / sum(frequency)) %>% filter(inpatient_count <= 10) %>% 
    full_join(data.frame(cohort = c(rep("ibis", 11), rep("control", 11)), inpatient_count = 0:10), 
              by = c("cohort", "inpatient_count")) %>% 
    replace(is.na(.), 0)


```

## Observed vs predicted admissions count proportions; negative binomial

```{r}
mod_nb_predict_admit <- function(data) {
    mod_nb <- MASS::glm.nb(inpatient_count ~ cohort, data = data, link = "log")
    ibis_df = data.frame(cohort = "ibis")
    control_df = data.frame(cohort = "control")
    
    mu_ibis_nb <- predict(mod_nb, newdata = ibis_df, type = "response")
    mu_control_nb <- predict(mod_nb, newdata = control_df, type = "response")
    
    theta_nb <- mod_nb$theta
    
    mod_nb_probs <- data.frame(inpatient_count = 0:10) %>%
        mutate(prob = dnbinom(inpatient_count, mu = mu_ibis_nb, size = theta_nb)) %>%
        mutate(cohort = "ibis") %>%
        bind_rows(data.frame(inpatient_count = 0:10) %>%
                      mutate(prob = dnbinom(inpatient_count, mu = mu_control_nb, size = theta_nb)) %>%
                      mutate(cohort = "control"))
    
    return(mod_nb_probs)
}

```

```{r}

legend_df <- tibble(
    x = 11 , y = 0,
    source = c("Predicted", "Observed")
)

mod_nb_predict_admit(patients_events) %>% 
    full_join(obs_freqs_cohort_inpatient, by = c("inpatient_count", "cohort")) %>% 
    mutate(.by = cohort, sum_freq = sum(frequency)) %>%
    mutate(expected = prob * sum_freq) %>% 
     ggplot(aes(x =inpatient_count)) +
    geom_point(aes(y = prob),
                    color = clrs5[1])  +
    geom_line(aes(y = prob), color = clrs5[1], alpha = 0.5) +
    geom_point(aes(y = density), color = clrs4[4], shape = 15, size = 2) +
    geom_line(aes(y = density), color = clrs4[4], alpha = 0.7) +

    # Add dummy layers to trigger legend entries
    geom_line(data = legend_df, aes(x = x, y = y, color = source), 
              # inherit.aes = FALSE,
              size = 1) +
    geom_point(data = legend_df, aes(x = x, y = y, color = source, shape = source), 
               size = 3) +
    
    scale_color_manual(values = c("Predicted" = clrs5[1], "Observed" = clrs4[4])) +
    scale_shape_manual(values = c("Predicted" = 16, "Observed" = 15)) +
    
      scale_x_continuous(breaks = 0:10) +
    coord_cartesian(xlim = c(0, 10)) +
    
    facet_wrap(~ cohort) +
    theme_minimal(base_size = 12) +
    theme(#axis.text.y = element_blank(),
          #legend.position = "none",
          #strip.background = element_blank(),
          #panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey80", color = NA),
          legend.position = "bottom"
    ) +
    labs(x = "Number of admissions", y =  "proportion",
         title = "Predicted and observed proportions",
         fill = NULL,
         color = NULL,
         shape = NULL) 
    
```

::::: columns
::: {.column width="50%"}
for the [**control**]{style="color:#f0be3d"} cohort

```{r}

control_df <- mod_nb_predict_admit(patients_events) %>% 
    full_join(obs_freqs_cohort_inpatient, by = c("inpatient_count", "cohort")) %>% 
    mutate(.by = cohort, sum_freq = sum(frequency),
           prevalence = frequency/sum_freq) %>%
    mutate(expected = prob * sum_freq) %>% filter(cohort == "control") %>% 
    mutate(chisq = (frequency - expected)^2 / expected)
 
control_df %>% select(inpatient_count, frequency, prevalence, expected, prob) %>% kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 14)

```
:::

::: {.column width="50%"}
For the [**ibis**]{style="color:#931e18"} cohort

```{r}
ibis_df <- mod_nb_predict_admit(patients_events) %>% 
    full_join(obs_freqs_cohort_inpatient, by = c("inpatient_count", "cohort")) %>% 
    mutate(.by = cohort, sum_freq = sum(frequency),
           prevalence = frequency/sum_freq) %>%
    mutate(expected = prob * sum_freq) %>% filter(cohort == "ibis") %>% 
    mutate(chisq = (frequency - expected)^2 / expected)
 
ibis_df %>% select(inpatient_count, frequency, prevalence, expected, prob) %>% kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 14)


```
:::
:::::

## Zero inflated negative binomial

#### With `cohort` as covariate on both zero inflation and count portions of the model

**This example for illustration only**

```{r}
mod_zinb_predict_admit <- function(data) {
    mod <- pscl::zeroinfl(inpatient_count ~ cohort | cohort, data = data, dist = "negbin")

    ibis_df = data.frame(cohort = "ibis")
    control_df = data.frame(cohort = "control")

    ibis_predict <- predict(mod, newdata = ibis_df, type = "prob")
    control_predict <- predict(mod, newdata = control_df, type = "prob")

    ibis_probs <- data.frame(inpatient_count = 0:10) %>%
        mutate(prob = ibis_predict[inpatient_count + 1]) %>%
        mutate(cohort = "ibis")

    control_probs <- data.frame(inpatient_count = 0:10) %>%
        mutate(prob = control_predict[inpatient_count + 1]) %>%
        mutate(cohort = "control")

    mod_probs <- bind_rows(ibis_probs, control_probs)

    return(mod_probs)
}

legend_df <- tibble(
    x = 11 , y = 0,
    source = c("Expected", "Observed"))

mod_zinb_predict_admit(patients_events) %>% 
    full_join(obs_freqs_cohort_inpatient, by = c("inpatient_count", "cohort")) %>% 
    mutate(.by = cohort, sum_freq = sum(frequency)) %>%
    mutate(expected = prob * sum_freq) %>% 
     ggplot(aes(x =inpatient_count)) +
    geom_point(aes(y = prob),
                    color = clrs5[1])  +
    geom_line(aes(y = prob), color = clrs5[1], alpha = 0.5) +
    geom_point(aes(y = density), color = clrs4[4], shape = 15, size = 2) +
    geom_line(aes(y = density), color = clrs4[4], alpha = 0.7) +

    # Add dummy layers to trigger legend entries
    geom_line(data = legend_df, aes(x = x, y = y, color = source), 
              # inherit.aes = FALSE,
              size = 1) +
    geom_point(data = legend_df, aes(x = x, y = y, color = source, shape = source), 
               size = 3) +
    
    scale_color_manual(values = c("Predicted" = clrs5[1], "Observed" = clrs4[4])) +
    scale_shape_manual(values = c("Predicted" = 16, "Observed" = 15)) +
    
      scale_x_continuous(breaks = 0:10) +
    coord_cartesian(xlim = c(0, 10)) +
    
    facet_wrap(~ cohort) +
    theme_minimal(base_size = 12) +
    theme(#axis.text.y = element_blank(),
          #legend.position = "none",
          #strip.background = element_blank(),
          #panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey80", color = NA),
          legend.position = "bottom"
    ) +
    labs(x = "Number of admissions", y =  "proportion",
         title = "Predicted and observed proportions",
         fill = NULL,
         color = NULL,
         shape = NULL) 
    
    
```

:::::: columns
:::: {.column width="50%"}
::: small
$$
\begin{aligned}
\textrm{counts}_i &\sim \text{ZINB}(\pi_i, \mu_i, \theta) \\
\log\left( \frac{\pi_i}{1 - \pi_i} \right) &= \gamma_0 + \gamma_1 \, \textrm{cohort}_i \\
\log(\mu_i) &= \beta_0 + \beta_1 \, \textrm{cohort}_i
\end{aligned}
$$
:::
::::

::: {.column width="50%"}
```{r}
mod_zinb <- pscl::zeroinfl(inpatient_count ~ cohort | cohort, data = patients_events, dist = "negbin")

df00 <-mod_zinb %>% coefficients() %>% 
    as.data.frame() %>%  rownames_to_column(var = "term")
colnames(df00) <- c("term", "estimate")

df00 %>%  kbl() %>% kable_paper("hover",full_width = F, html_font = "Arial", font_size = 20)
    
```

[$\theta$: `r round(mod_zinb$theta, 3)`]{style="font-size:75%"}
:::
::::::

**This example for illustration only** The coeffs are not significant, but see models below.

```{r}
invlogit <- function(x){1/(1+exp(-x))}
```

Zero inflation probabilities

-   control: $logit^{-1}$ `r round(mod_zinb$coefficients$zero[1], 3)` = `r round(invlogit(mod_zinb$coefficients$zero[1]), 3)`

-   ibis: $logit^{-1}$ (`r mod_zinb$coefficients$zero[1]` + `r mod_zinb$coefficients$zero[2]`) = `r invlogit(mod_zinb$coefficients$zero[1] + mod_zinb$coefficients$zero[2])`

Count mean for ibis also reduced by factor of exp(`r mod_zinb$coefficients$count[2]`) = `r exp(mod_zinb$coefficients$count[2])`.

## Observed vs expected admissions counts; zero inflated negative binomial

::::: columns
::: {.column width="50%"}
for the [**control**]{style="color:#f0be3d"} cohort

```{r}

control_df <- mod_zinb_predict_admit(patients_events) %>% 
    full_join(obs_freqs_cohort_inpatient, by = c("inpatient_count", "cohort")) %>% 
    mutate(.by = cohort, sum_freq = sum(frequency),
           prevalence = frequency/sum_freq) %>%
    mutate(expected = prob * sum_freq) %>% filter(cohort == "control") %>% 
    mutate(chisq = (frequency - expected)^2 / expected)
 
control_df %>% select(inpatient_count, frequency, prevalence, expected, prob) %>% kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 14)




```
:::

::: {.column width="50%"}
For the [**ibis**]{style="color:#931e18"} cohort

```{r}
ibis_df <- mod_zinb_predict_admit(patients_events) %>% 
    full_join(obs_freqs_cohort_inpatient, by = c("inpatient_count", "cohort")) %>% 
    mutate(.by = cohort, sum_freq = sum(frequency),
           prevalence = frequency/sum_freq) %>%
    mutate(expected = prob * sum_freq) %>% filter(cohort == "ibis") %>% 
    mutate(chisq = (frequency - expected)^2 / expected)
 
ibis_df %>% select(inpatient_count, frequency, prevalence, expected, prob) %>% kbl() %>% kable_classic(full_width = F, html_font = "Arial", font_size = 14)



```
:::
:::::

# More models; summary and comparisons

Below we fit more models and summarize eight models. All the models use `cohort`, `chf`, and `atrial_fibrillation` as covariates.

-   zero inflated vs not

-   poisson vs negative binomial distribution

-   with and without `age` as a covariate.

### Zero inflated age

Two of the models include `age` as a covariate for the zero inflation part of the model, as well as  `cohort`, `chf`, and `atrial_fibrillation` on the count portions. We highlight those here. The full summary of all the models follows.

```{r}
mod_pois1 <- glm(inpatient_count ~ cohort  + chf + atrial_fibrillation, data = patients_events, family = poisson(link = "log"))

mod_pois2 <- glm(inpatient_count ~ cohort  + age + chf + atrial_fibrillation, data = patients_events, family = poisson(link = "log"))

mod_nb1 <-  MASS::glm.nb(inpatient_count ~ cohort +  chf + atrial_fibrillation , data = patients_events, link = "log")

mod_nb2 <- MASS::glm.nb(inpatient_count ~ cohort + age + chf + atrial_fibrillation, data = patients_events, link = "log")


mod_zip1 <- pscl::zeroinfl(inpatient_count ~ cohort  + chf + atrial_fibrillation | 1, data = patients_events, dist = "poisson") 
mod_zinb1 <- pscl::zeroinfl(inpatient_count ~ cohort  + chf + atrial_fibrillation | 1, data = patients_events, dist = "negbin") 

mod_zip2 <- pscl::zeroinfl(inpatient_count ~ cohort  + age + chf + atrial_fibrillation | 1, data = patients_events, dist = "poisson") 
mod_zinb2 <- pscl::zeroinfl(inpatient_count ~ cohort  + age + chf + atrial_fibrillation | 1, data = patients_events, dist = "negbin")

mod_zip3 <- pscl::zeroinfl(inpatient_count ~ cohort  + age + chf + atrial_fibrillation | age, data = patients_events, dist = "poisson") 
mod_zinb3 <- pscl::zeroinfl(inpatient_count ~ cohort  + age + chf + atrial_fibrillation | age, data = patients_events, dist = "negbin")


```

```{r}

### Pois
dfpois1 <- mod_pois1 %>% coefficients() %>% 
    as.data.frame() %>%  rownames_to_column(var = "term")
colnames(dfpois1) <- c("term", "estimate")

pvals <- mod_pois1 %>% tidy() %>% dplyr::select(p.value) %>% pull() %>% round(4)
dfpois1 <- dfpois1  %>% mutate(pval = pvals) %>% mutate(model = "Pois1")
  
dfpois2 <-mod_pois2 %>% coefficients() %>% 
    as.data.frame() %>%  rownames_to_column(var = "term")
colnames(dfpois2) <- c("term", "estimate")

pvals <- mod_pois2 %>% tidy() %>% dplyr::select(p.value) %>% pull() %>% round(4)
dfpois2 <- dfpois2  %>% mutate(pval = pvals) %>% mutate(model = "Pois2")

### NB

dfnb1 <- mod_nb1 %>% coefficients() %>% 
    as.data.frame() %>%  rownames_to_column(var = "term")
colnames(dfnb1) <- c("term", "estimate")

pvals <- mod_nb1 %>% tidy() %>% dplyr::select(p.value) %>% pull() %>% round(4)
dfnb1 <- dfnb1  %>% mutate(pval = pvals) %>% mutate(model = "NB1")
  
dfnb2 <-mod_nb2 %>% coefficients() %>% 
    as.data.frame() %>%  rownames_to_column(var = "term")
colnames(dfnb2) <- c("term", "estimate")

pvals <- mod_nb2 %>% tidy() %>% dplyr::select(p.value) %>% pull() %>% round(4)
dfnb2 <- dfnb2  %>% mutate(pval = pvals) %>% mutate(model = "NB")


### ZI

##### 
count_coefs <- summary(mod_zip1)$coefficients$count %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>%
    mutate(component = "count") %>% select(term, component, estimate, p.value) %>%  mutate(p.value = round(p.value, 4))
zero_coefs <- summary(mod_zip1)$coefficients$zero %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>% 
    mutate(component = "zero") %>%  select(term, component, estimate, p.value)

dfzip1 <- bind_rows(count_coefs, zero_coefs) 
dfzip1 <- dfzip1 %>% mutate(model = "ZIP1") 

count_coefs <- summary(mod_zinb1)$coefficients$count %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>%
    mutate(component = "count") %>% select(term, component, estimate, p.value) %>%  mutate(p.value = round(p.value, 4))
zero_coefs <- summary(mod_zinb1)$coefficients$zero %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>% 
    mutate(component = "zero") %>%  select(term, component, estimate, p.value)


dfzinb1 <- bind_rows(count_coefs, zero_coefs) 
dfzinb1 <- dfzinb1 %>% mutate(model = "ZINB1") 

#########

count_coefs <- summary(mod_zip2)$coefficients$count %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>%
    mutate(component = "count") %>% select(term, component, estimate, p.value) %>%  mutate(p.value = round(p.value, 4))
zero_coefs <- summary(mod_zip2)$coefficients$zero %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>% 
    mutate(component = "zero") %>%  select(term, component, estimate, p.value)

dfzip2 <- bind_rows(count_coefs, zero_coefs) 
dfzip2 <- dfzip2 %>% mutate(model = "ZIP2") 

count_coefs <- summary(mod_zinb2)$coefficients$count %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>%
    mutate(component = "count") %>% select(term, component, estimate, p.value) %>%  mutate(p.value = round(p.value, 4))
zero_coefs <- summary(mod_zinb2)$coefficients$zero %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>% 
    mutate(component = "zero") %>%  select(term, component, estimate, p.value)

dfzinb2 <- bind_rows(count_coefs, zero_coefs) 
dfzinb2 <- dfzinb2 %>% mutate(model = "ZINB2") 

#######

count_coefs <- summary(mod_zip3)$coefficients$count %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>%
    mutate(component = "count") %>% select(term, component, estimate, p.value) %>%  mutate(p.value = round(p.value, 4))
zero_coefs <- summary(mod_zip3)$coefficients$zero %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>% 
    mutate(component = "zero") %>%  select(term, component, estimate, p.value)


dfzip3 <- bind_rows(count_coefs, zero_coefs) 
dfzip3 <- dfzip3 %>% mutate(model = "ZIP3") 

count_coefs <- summary(mod_zinb3)$coefficients$count %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>%
    mutate(component = "count") %>% select(term, component, estimate, p.value) %>%  mutate(p.value = round(p.value, 4))

zero_coefs <- summary(mod_zinb3)$coefficients$zero %>%
 as.data.frame() %>%  rownames_to_column(var = "term") %>% 
    mutate(estimate = Estimate, p.value = `Pr(>|z|)`) %>% 
    mutate(component = "zero") %>%  select(term, component, estimate, p.value)


dfzinb3 <- bind_rows(count_coefs, zero_coefs) 
dfzinb3 <- dfzinb3 %>% mutate(model = "ZINB3") 

##########
########

```

::: {.column width="50%"}

**Zero inflated Poisson with age zero inflation**

```{r}
dfzip3 %>% select(-model) %>%  kbl(digits = 4)  %>%  kable_paper()
```
:::

::: {.column width="50%"}
**Zero inflated negative binomial with age zero inflation**

```{r}
dfzinb3 %>% select(-model) %>% kbl(digits = 4)  %>%  kable_paper()
```
:::

### Coefficients for all models

**Poisson and negative binomial; no zero inflation**

```{r}
df_poisnb <- bind_rows(dfpois1, dfpois2, dfnb1, dfnb2) 

df_poisnb %>% select(-pval) %>%  pivot_wider(names_from = term, values_from = c(estimate)) %>% 
    kbl(digits = 4) %>% kable_paper()

```

**Poisson and negative binomial; no zero inflation - long format with p-values**

```{r}


df_poisnb %>% kbl(digits = 4)  %>%  kable_paper()

```

**Zero inflated Poisson and negative binomial.**


```{r}

df_zipzinb <- bind_rows(dfzip1, dfzinb1, dfzip2, dfzinb2, dfzip3, dfzinb3)
df_zipzinb %>% kbl(digits = 4) %>% kable_paper()


```

### Fit

We can use; eg, chi-square test on the log likelihood to check whether the difference in models is statistically significant. See the above tables to infer the covariates and type of model for each model name.

```{r}
models <- list(
  Pois1  = mod_pois1,
  Pois2  = mod_pois2,
  NB1    = mod_nb1,
  NB2    = mod_nb2,
  ZIP1   = mod_zip1,
  ZINB1  = mod_zinb1,
  ZIP2   = mod_zip2,
  ZINB2  = mod_zinb2,
  ZIP3   = mod_zip3,
  ZINB3  = mod_zinb3
)

# Extract log-likelihoods
loglik_tbl <- imap_dfr(models, ~{
  ll <- logLik(.x)
  tibble(
    model = .y,
    logLik = as.numeric(ll),
    df = attr(ll, "df")
  )
}) %>%
  mutate(
    AIC = map_dbl(models, AIC),
    BIC = map_dbl(models, BIC)
  ) 

 loglik_tbl %>%    kbl() %>% kable_paper()
               
```


```{r}
LRT <- 2 * (logLik(mod_zinb3) - logLik(mod_zip3))
pval <- pchisq(LRT, df = 1, lower.tail = FALSE)
 
```

For example, comparing the ZIP3, and ZINB3, which have the same covariates and model specification, except with the latter having an additional dispersion parameter on the count portion of the model, using the we find `r pval `

# Bayesian zero inflated Poisson regression

Bayesian models often offer some advantages. We get an entire distribution for every parameter modeled-not just point estimates and confidence intervals. We can also get distributions for any statistic.

We first consider a zero inflated model with intercept-only zero inflation portion, for quick comparison with the analogous frequentist model. We see that results are consistent, and in particular the credible intervals for the coefficients are bounded away from zero.

## Bayes intercept only zero inflation, no `age` covariate

$$ 
\begin{aligned}
\textrm{counts}_i & \sim ZIP(\pi_i, \mu_i) \\
\log \mu_i & = \beta_0 + \beta_1 \textrm{cohort}_i + \beta_2\textrm{chf}_i + \beta_3\textrm{atrialfibrillation}_i\\
\log \frac{\pi_i}{1 - \pi_i} & = \gamma_0 \\
\end{aligned}
$$

#### Model results; compare frequentist ZIP model

```{r}

## model fits in bayes_brms_2025-10.R 

load("../data/zip_bayes_2025-10.RData")
```

::::: columns
::: {.column width="50%"}
**Bayes**

```{r}
dftemp <- fixef(zip_bayes) %>% as.data.frame() %>% 
    rownames_to_column(var = "term")

dftemp %>%  #mutate(term = c("(Intercept)", "cohortibis", "(Intercept)", "condition_count")) %>% 
    mutate(component = c("count", "zero", "count", "count", "count")) %>% 
    select(component, everything()) %>% kbl() %>% kable_paper("hover",full_width = F, html_font = "Arial", font_size = 16)

```
:::

::: {.column width="50%"}
**Frequentist**

```{r}
# Extract count model coefficients
    count_coefs <- summary(mod_zip1)$coefficients$count %>%
        as_tibble(rownames = "term") %>%
        mutate(component = "count")
    
    # Extract zero-inflation model coefficients
    zero_coefs <- summary(mod_zip2)$coefficients$zero %>%
        as_tibble(rownames = "term") %>%
        mutate(component = "zero")
    
    # Combine and clean up
    tidy_mod <- bind_rows(count_coefs, zero_coefs) %>%
        rename(
            Estimate = Estimate,
            `Std. Error` = `Std. Error`
        ) %>%
        select(component, term, Estimate, `Std. Error`) %>%
        mutate(across(where(is.numeric), ~ round(.x, 3)))
    
    # View or print for Quarto
    tidy_mod %>% as.data.frame() %>% kbl() %>% kable_paper("hover",full_width = F, html_font = "Arial", font_size = 16)
```
:::
:::::

#### Posterior distributions

::::: columns
::: {.column width="50%"}
```{r}

mcmc_hist(zip_bayes, pars = c("b_cohortibis", "b_chf", "b_atrial_fibrillation"),
           facet_args = list(ncol = 2)) +
  labs(title = "Posterior distributions for zero-inflated model parameters")


```
:::

::: {.column width="50%"}
```{r}
mcmc_intervals(zip_bayes, pars = vars(starts_with("b_"))) +
 labs(title = "Posterior credible intervals for zero-inflated model parameters")
```
:::
:::::

100 draws from the posterior predictive distribution

```{r}

set.seed(12)
y_rep <- posterior_predict(zip_bayes)

y_obs <- zip_bayes$data$inpatient_count

ppc_dens_overlay(y = y_obs, yrep = y_rep[1:100, ]) +
  labs(
       x = "Number of admissions", y = NULL) +
  theme_minimal(base_size = 12)
```

#### Post predictive checks

We can check how the distribution of proportions for different values of `inpatient_count` compares with those in the data.

```{r}
# Define observed y and posterior predictive draws
y_obs <- zip_bayes$data$inpatient_count
y_rep <- posterior_predict(zip_bayes)

# Function to compute proportion of a given count
make_prop_stat <- function(k) {
    function(x) mean(x == k)
}

# Loop over counts 0 through 10 and compute stats
stats_df <- map_dfr(0:5, function(k) {
    stat_fun <- make_prop_stat(k)
    
    tibble(
        count = k,
        yrep_stats = apply(y_rep, 1, stat_fun),   # each row is a draw
        y_obs_stat = stat_fun(y_obs)
    )
}, .id = "id") %>%
    mutate(count = as.integer(count))

# Unnest for ggplot
stats_long <- stats_df %>%
    select(count, yrep_stats, y_obs_stat) %>%
    unnest(yrep_stats = yrep_stats)

# Plot
ggplot(stats_long, aes(x = yrep_stats)) +
    geom_density(fill = "skyblue", alpha = 0.6) +
    geom_vline(aes(xintercept = y_obs_stat), color = "red", linetype = "dashed") +
    facet_wrap(~ count, scales = "free") +
    labs(
        title = "Posterior predictive distribution of proportion for each count (0–10)",
        x = "Proportion in posterior samples",
        y = "Density"
    ) +
    theme_minimal()
```


## Bayes zero inflated with `age` covariate for count and zero inflation portions of the model

$$ 
\begin{aligned}
\textrm{counts}_i & \sim ZIP(\pi_i, \mu_i) \\
\log \mu_i & = \beta_0 + +\beta_1\textrm{cohort}_i + \beta_2\textrm{age}_i  + \beta_3\textrm{chf}_i + \beta_4\textrm{atrialfibrillation}_i\\
\log \frac{\pi_i}{1 - \pi_i} & = \gamma_0 + \gamma_1\textrm{age}_i  \\
\end{aligned}
$$
**Note that for this model we scale the `age` covariate**

$$
age \rightarrow \frac{\textrm{age} - 60}{10}
$$ 

for interpretability and for numerical stability. This affects the value of the coefficient estimates, but not the model fit, significance, or effect on the outcome.

```{r}

## model fits in bayes_brms_2025-10.R 

load("../data/zip3_bayes_2025-10.RData")
```

#### Posterior estimates, credible intervals


```{r}
dftemp <- fixef(zip3_bayes) %>% as.data.frame() %>% 
    rownames_to_column(var = "term")

dftemp %>%  #mutate(term = c("(Intercept)", "cohortibis", "(Intercept)", "condition_count")) %>% 
    mutate(component = c("count", "zero", "count", "count", "count", "count", "zero")) %>% 
    select(component, everything()) %>% kbl() %>% kable_paper("hover",full_width = F, html_font = "Arial", font_size = 16)

```



::::: columns
::: {.column width="50%"}
```{r}

mcmc_hist(zip3_bayes, pars = c("b_cohortibis", "b_age", "b_chf", "b_atrial_fibrillation", "b_zi_age"),
           facet_args = list(ncol = 2)) +
  labs(title = "Posterior distributions for zero-inflated model parameters")


```
:::

::: {.column width="50%"}
```{r}
mcmc_intervals(zip3_bayes, pars = vars(starts_with("b_"))) +
 labs(title = "Posterior credible intervals for zero-inflated model parameters")
```
:::
:::::

100 draws from the posterior predictive distribution

```{r}

set.seed(12)
y_rep <- posterior_predict(zip3_bayes)

y_obs <- zip3_bayes$data$inpatient_count

ppc_dens_overlay(y = y_obs, yrep = y_rep[1:100, ]) +
  labs(
       x = "Number of admissions", y = NULL) +
  theme_minimal(base_size = 12)
```

#### Post predictive checks

We can check how the distribution of proportions for different values of `inpatient_count` compares with those in the data.

```{r}
# Define observed y and posterior predictive draws
y_obs <- zip3_bayes$data$inpatient_count
y_rep <- posterior_predict(zip3_bayes)

# Function to compute proportion of a given count
make_prop_stat <- function(k) {
    function(x) mean(x == k)
}

# Loop over counts 0 through 10 and compute stats
stats_df <- map_dfr(0:5, function(k) {
    stat_fun <- make_prop_stat(k)
    
    tibble(
        count = k,
        yrep_stats = apply(y_rep, 1, stat_fun),   # each row is a draw
        y_obs_stat = stat_fun(y_obs)
    )
}, .id = "id") %>%
    mutate(count = as.integer(count))

# Unnest for ggplot
stats_long <- stats_df %>%
    select(count, yrep_stats, y_obs_stat) %>%
    unnest(yrep_stats = yrep_stats)

# Plot
ggplot(stats_long, aes(x = yrep_stats)) +
    geom_density(fill = "skyblue", alpha = 0.6) +
    geom_vline(aes(xintercept = y_obs_stat), color = "red", linetype = "dashed") +
    facet_wrap(~ count, scales = "free") +
    labs(
        title = "Posterior predictive distribution of proportion for each count (0–10)",
        x = "Proportion in posterior samples",
        y = "Density"
    ) +
    theme_minimal()
```



# Math notes

## Linear models

Continuous response $Y$ (eg, heart rate) as a function of predictors; aka **covariates**, $X_j$ (eg, cholesterol, smoker)

$$Y  \sim N(\mu , \sigma^2)$$ where the conditional mean is a linear function of the predictors

$$\mu = E(Y |X ) = \beta_0 + \sum_{j=1}^p \beta_j X_j = X \boldsymbol{\beta}$$

-   $\beta_j$ are estimated by minimizing the sum of squares errors, $$\sum_i (y_i - (\beta_0 - \sum_j \beta_j x_{ij}))^2 = ||\mathbf{y} - \mathbf{X}\boldsymbol{\beta}||^2_2$$

-   We can interpret the coefficients directly as effect sizes.

## Generalized linear models

We model *a function of* the conditional mean as a linear function

$$g(\mu ) = \beta_0 + \sum_{j=1}^p \beta_j X_j =  X \boldsymbol{\beta}$$

$g$ is called a *link* function.

#### Example: Logistic regression

$$Y \sim \textrm{Bernoulli}(\mu )$$ Coin toss with probability $\mu$ of heads, $1 - \mu$ of tails.

$$g(\mu ) = \rm{logit} \ \mu := \log \left(\frac{\mu}{1 - \mu}\right)  =  X \boldsymbol{\beta}$$

$$\mu = \rm{logit}^{-1}(X \boldsymbol{\beta})$$

## Likelihood

To find $\beta_j$, we typically maximize the (log) likelihood function.

For logistic regression, with $n$ independent observations $y_i =$ 0 or 1, the joint probability is

$$p({\bf{y}} | X_i) = \mu_i^{y_i} (1 - \mu_i)^{1 - y_i}$$

The log likelihood is then

$$logLik(\boldsymbol{\beta}) = \sum_{i=1}^n y_i \log(\mu_i) + (1 - y_i)\log (1 - \mu_i)$$

Where are the $\beta$'s?

Recall that $\mu_i = \rm{logit}^{-1}(X_i \boldsymbol{\beta})$)

## Poisson regression

Counts $Y$ modeled as

$$
 p(Y  = y; \mu) = \frac{\mu^y e^{-\mu }}{y!}
$$ with "canonical" link

$$ 
g(\mu ) = \log(\mu ) = X \boldsymbol{\beta}
$$

Likelihood

$$logLik(\boldsymbol{\boldsymbol{\beta}}) = \sum_{i=1}^n \left( y_i \log \mu_i - \mu_i - \log (y_i!) \right)$$

## Fun fact

> For a linear model, the minimum sum of squares estimate is the same as the maximum likelihood estimate.

Models

-   Zero inflated Poisson regression

-   Zero inflated negative binomial regression

-   Bayes versions of the above

## Negative binomial distribution

Often used on *overdispersed* data: $\mu < \sigma^2$.

$$p(Y = y; \mu, \theta) = \binom{y + \theta - 1}{\theta} \left(\frac{\mu}{\mu + \theta}\right)^y \left(\frac{\theta}{\mu + \theta}\right)^\theta$$

-   *Dispersion* parameter $\theta > 0$; fixed- does not vary with covariates like $\mu$.

-   $\theta$ is estimated by the model

**Conditional mean** $E(Y|X) = \mu$. We again model with log link

$$\log \mu = X \boldsymbol{\beta}$$

**Variance**

$$Var(Y|X) = \mu + \mu^2/\theta$$

$\theta$ part of the model fit - unlike $\sigma^2$ in linear regression.

## Zero inflated Poisson regression

Define $Z \sim Bernoulli(\pi)$ - a coin flip with probability $\pi$ of heads.

$$
Y = \begin{cases}
0 & \text{if} \  Z = 1 \\
\sim Pois(\mu)  & \text{if} \ Z = 0 
\end{cases}
$$

-   $Z$ models the **zero-inflated** portion - the "extra" zeros.

-   The additional count data, including zeros, is modeled with the Poisson distribution with mean $\mu$.

$$
p(Y = y; \mu, \pi) = \begin{cases}
\pi + (1 - \pi) e^{-\mu} & \text{if } y = 0 \\
(1 - \pi) \frac{\mu^y e^{-\mu}}{y!}  & \text{if } y > 0
\end{cases}
$$

(Recall Poisson distribution is $P(y; \mu) = \mu^y e^{-\mu}/y!$)

-   $\log \frac{\pi}{1 -\pi} =$ linear function of some covariates

-   $\log(\mu) =$ linear function of some covariates



#### Likelihood function

We again estimate the coefficients using log likelihood.


$$
\begin{align*}
logLik(\mathbf{\beta}, \mathbf{\gamma}) = \sum_{i=1}^n \Big(& \mathbf{1}_{\{y_i = 0\}} \cdot \log \left( \pi_i + (1 - \pi_i) e^{-\mu_i} \right) \\
& + \mathbf{1}_{\{y_i > 0\}} \cdot \left( \log(1 - \pi_i) + y_i \log(\mu_i) - \mu_i - \log(y_i!) \right) \Big)
\end{align*}
$$

## Bayesian statistical modeling

#### Starts with Bayes' Rule

The conditional probability of $B_k$ given $A$ is

$$\begin{aligned}
P(B_k \ | \ A) & = \frac{P(A \ | \ B_k) P(B_k)}{P(A)} \\
               & = \frac{P(A \ | \ B_k) P(B_k)}{\sum_i P(A \ | \ B_i) P(B_i)}
\end{aligned}$$

where $A$ and $B_j$ are events with $B_j$ a partition of the sample space. The vertical bar indicates conditional probability

#### The standard disease/positive test example

$$P(D | +) = \frac{P(+ | D) \ P(D)}{P(+ | D) P(D) + P(+ | \bar{D}) P(\bar{D})} $$

## Bayes' Rule for probability *densities* for model parameters

$$p(\boldsymbol{\theta} | y, X) = \frac{p(\boldsymbol{\theta}) p(y | \boldsymbol{\theta}, X)}{\int p(y | \boldsymbol{\theta}, X) p(\boldsymbol{\theta}) d\boldsymbol{\theta}}$$

-   *random vector* of model parameters $\boldsymbol{\theta}$ (our $\beta$'s and $\gamma$'s)

-   *fixed* predictor data $X$ and response data $y$

-   $p(\boldsymbol{\theta})$ is the *prior distribution* for the parameters

-   $p(y | \boldsymbol{\theta}, X)$ is the *likelihood* of the data given the parameters $\theta$ - same as the likelihood function in frequentist statistics.

-   $p(\theta | x)$ is the *posterior* distribution for the parameters $\theta$.

The denominator is an integration over the parameter space; typically intractable $\Rightarrow$ Markov Chain Monte Carlo (MCMC) methods to approximate the posterior distribution.

## Posterior predictive distribution

Once you have the $\theta$ posterior, you can compute the posterior predictive distributions of a new observation $x_0$, given the data $X$.

$$\begin{align*}
p(x_0|X) & = \int p(x_0, \theta | X)\, d\theta \\
 \\
& = \int p(x_0| \theta, X) \, p(\theta |X) , d\theta \\
\\
& = \int p(x_0|\theta) \,  p(\theta | X) \, d\theta\\
\end{align*}$$

Can also get a distribution for any statistic of interest.

## Bayesian inference

-   Parameters are regarded as random variables, data fixed

-   We get an entire distribution for every parameter, and hence for any statistic we wish to compute

-   No p-values, no hypothesis testing!

## Example

-   $\pi$ is the probability of heads in a single coin toss,

-   data is the sequence of heads and tails in 100 tosses

::::: columns
::: {.column width="50%"}
```{r}
plot_beta_binomial(1, 1, 7, 10) +
  labs(title = "A flat prior")

```
:::

::: {.column width="50%"}
```{r}
plot_beta_binomial(5, 5, 7, 10) +
  labs(title = "A more informative prior")
```
:::
:::::

By contrast, our maximum likelihood estimate of $\pi$ would be the peak of the likelihood, which is the same as the posterior for flat prior.

